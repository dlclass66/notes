# 概述

redis是开源的 存储在内存中的数据库 因为在内存中所以速度快（相对于mysql） 基于c语言

# 数据结构

redis是以键值对存储数据的 key只能是字符串 value可以是字符串 链表 哈希表 集合 有序集合

## 字符串

因为基于c语言 而c语言的字符串存在一些缺陷（获取长度要o(n)复杂度， 无法动态扩容）
所以进行了一定封装 类似vector的想法

```c
struct sdshdr{
    //简单动态数组 sds
    unsigned int len;
    //字符串已用长度
    unsigned int alloc;
    //字符串申请的长度
    unsigned char flags;
    //字符串的类型 根据len alloc的长度区分
    char buf[];
    //实际存储字符串的结构
};
```

## 链表

底层实现是双向链表

## 哈希表

以拉链法实现 （散列表）
dictht 单纯表示一个哈希表
dictEntry 哈希表的一项 也就是一个键值对
dict redis给外界调用的哈希表结构 包含两个dictht

```c
struct dictht{
    dictEntry** table; 
    // 哈希表数组（相当于2维） 里面元素是哈希表项  
    unsigned long size;
    //hash表大小 （桶的大小）
    unsigned long sizemask;
    //避免溢出
    unsigned long used;
    //已经包含的键值对数量 
}
struct dictEntry{
    void* key; //
    union{
        void* val;
        uint64_t u64;
        int64_t s64;
        double d;
    } v; //用union存储值
    struct dictEntry* next; //因为是散列表 所以需要指向下一个
}
struct dict{
    dictType* type;
    void* privdata;
    dictht ht[2];
    //存储两个 rehash（扩容）时用第二个存新的 第一个指针指向第二个 第二个指向nullptr
    int rehashidx;
}
```

如果redis没有后台备份 负载因子（键值对数量除以桶的数量）大于1就rehash 如果在后台备份 负债因子大于5执行

## 集合

### 整数集合

```c
struct inset{
    //编码方式 包含int16_t, int32_t, int64_t
    uint32_t encoding;
    //集合长度 
    uint32_t length;
    //元素数组
    int8_t contents[];
};
```

当集合只包含整数值元素且集合元素数量不多是采用此方式
维护了一个有序的数组 可以采用二分查找

## 有序集合 zset

使用跳表（双向链表 多级索引）查找复杂度降为对数级别 可以用来实现热搜

# 持久化

## rdb

快照 全量备份

### 手动触发

save 会阻塞主进程 不建议使用
bgsave fork一个子进程

### 自动触发

save m n 在m秒内发生n次变化就bgsave

## aof

记录操作的指令（写指令）

### 手动触发

bgrewriteaof

### 自动触发

appendonly yes
有三种策略

1. always 每个写命令执行完成就刷新aof 影响性能
2. everysec 每秒刷新aof
3. no 让操作系统决定频率
一般采用everysec

## 4版本后默认使用aof和rdb混合模式

# 缓存

## 缓存淘汰

要加入新的键值对时发现内存已满 需要淘汰
基本模式

1. fifo 队列 淘汰最老的
2. lru 最近最少使用 可以用一个双向链表加一个哈希表实现
3. lfu 最不经常使用 和使用次数有关 将元素按使用次数排序
4. 随机

## 过期删除

处理设置了过期时间的已经过期的kv对
策略

1. 惰性删除 不会主动检查 使用kv对时发现已经过期就删除 对cpu友好 但是可能造成内存浪费
2. 定时删除 维护定时器 到期主动删除 cpu有额外开销
3. 定期删除 一定时间间隔检查过期的kv对并删除

## 缓存一致

保证mysql和redis数据一致

### cache aside

当缓存数据有更新 删除缓存数据而不是更新缓存数据（写操作）
这里涉及到一个操作顺序的问题 是先更新数据库还是先删除缓存
为了在读写并发时数据一致 先更新数据库再删除缓存（删除缓存速度远大于更新数据库）
读操作先查找缓存 有就读缓存 没有就查找数据库 再将数据库条目写入缓存

## 缓存击穿

查询的数据的值不在缓存中 在数据库中

热门数据在缓存中过期 但该数据仍被大量访问造成缓存击穿 可能让mysql直接宕机
解决方法

1. mysql方面 使用锁 减少击穿后的直接流量
2. redis方面 设置热点数据永不过期 或者后台用进程 如果热点数据快要过期 就把mysql的数据回填缓存层 重新设置过期时间

## 缓存穿透

查询的数据缓存里面没有 数据库里面也没有
解决方法

1. 拦截非法查询请求
2. 缓存空对象（无效查询就返回这个空对象）
3. 布隆过滤器（快速过滤掉很多无效请求 但是一部分无效请求会被识别为有效 有效请求一定不会被过滤）

## 缓存雪崩

一大批缓存中的数据同时失效 对这些数据的请求就全部打到数据库上 多点的缓存击穿
mysql方面解决方法和缓存击穿一致
redis方面

1. 设置热点数据永不过期
2. 分析失效时间 使失效时间尽量分散
3. 缓存预热 在上线前 提前将热数据加载到缓存系统

# 集群

## 主从复制

为了保证redis的容灾 高可用 使用多个库 可以是一个主库 多个从库
主库负责执行客户端的写命令（之后再和从库数据同步） 从库负责读命令
从库上线时 先和主库之间握手通信 进行验证 握手完成后 从库向主库发送PSYN同步命令 发送主库的id 复制的进度偏移量offset 主库根据这些信息判断是进行全量复制还是断线后重复制
全量复制的操作

* 主库执行bgsave 生成rdb同时开辟缓冲区 记录命令执行过程中收到的新数据命令
* rdb生成完成后发送给从库 从库通过rdb文件恢复
后续的变更主库会把命令发给从库 从库执行命令保持同步（命令传播阶段）
断线后重复制
需要服务器运行id判断断线过程中主库有没有变更 若变更则执行全量复制
然后根据复制偏移量 和复制挤压缓存区判断是否可以增量复制

## 哨兵

一个不提供数据服务的redis服务器 负责监控其他服务器的运行状态 主库掉线时重新选择主库
判断服务器下线的方法

* 心跳 定期向所有服务器发送消息 未收到恢复则标记为主观下线（主库）
* 若一个服务器被半数哨兵标记为主观下线 则标记为客观下线（主库），从从库中挑选新主库
哨兵会向新挑选出的主库发送命令slave of no one 然后向其他从库发送主库ip端口号 如果此时原先主库重新上线 会被降级为从库

## cluster 分布式数据库解决方案

自动将数据切分给多个节点存储 即使其中一部分宕机 仍然可以继续执行数据操作
分区策略 采用虚拟槽 使用类似hash的方式决定存储在哪个redis服务器
查询策略 每个节点存储整个集群的节点信息（元信息）这些元信息会使用gossip协议传播(类似病毒传播) 每隔一段时间就传递给相邻的k个节点
