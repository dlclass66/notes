# 认识redis
## 与memcached区别
redis的优势
1. 支持的数据类型更丰富
2. 支持持久化
3. 原生支持集群
4. 支持订阅发布模型， lua脚本， 事务
## redis作为缓存的原因
1. 高性能 数据在内存 读写速度快
2. 高并发 每秒请求数大约为mysql10倍
# redis的数据结构
## 种类及应用场景
常见5种 后续又有4种
能实现交并补的 set zset用来热搜
bitmap 二值状态统计 比如登录状态
hyperloglog 海量数据基数统计
geo 存储地理位置信息 比如滴滴
stream 消息队列
## 常见5种实现
### string
sds 简单动态字符串
相对于c字符串有以下优点
1. 可以保存任意二进制数据
2. 获取字符串长度复杂度为常数时间
3. 安全 拼接不会溢出
### list
最新的使用quicklist 一个一个小的压缩链表像双向链表一样连接而成
类似deque ziplist空间连续
### hash
较小的采用listpack（对ziplist的改造） 大的采用散列表
### set
数量较少且元素都是整数 采用整数集合 其他采用hash表
### zset 
数量少采用listpack 其他采用跳表
# redis线程模型
## 单线程
单线程是说redis完成客户请求是由一个主线程完成的
但是redis程序有后台进程  关闭文件 aof刷盘 异步释放redis内存都是子进程完成的（大key使用unlink异步删除）
后台线程是消费者 生产者把耗时任务丢到任务队列中 后台线程不断轮询 有任务就拿出来执行
## redis单线程模式
epoll 三种事件 连接事件 读事件 写事件 和web服务器有很多类似的地方
参考小林code
## redis单线程为什么这么快
单线程网络io和执行命令的原因
1. 大部分操作在内存 cpu不是瓶颈
2. 单线程避免了很多多线程的问题 比如死锁 线程切换开销
3. 使用了io多路复用 可以同时监听多个套接字
如果想利用服务器的多核cpu可以启动多个节点
## redis6.0之后的多线程
为了提高网络io效率 网络io操作使用了多线程
# redis持久化
## 如何实现数据不丢失
三种方式
1. aof 记录操作（写）
2. rdb 快照
3. 混合 由上述两种的优点
## aof
### 先执行命令再将命令记录到aof日志
好处
1. 避免检查语法的开销（如果把语法错误的命令写入aof可能会出错）
2. 不会阻塞写操作命令
缺点
1. 数据可能丢失
2. 可能阻塞其他操作 因为aof日志也是在主线程执行
### 写入过程
1. 命令追加到用户态缓存区
2. 通过write（）系统调用 拷贝到内核缓冲区
3. 由内核决定什么时候落盘
第三步有三种策略
1. always 每次执行完写操作就落盘 对性能影响大
2. everysec 每秒写一次盘 常用
3. no 由操作系统控制 一般约为30s一次
### aof过大的重写
参考当前数据库状态重新生成aof 
过程 使用子**进程**（fork出）bgrewriteaof
两点好处
1. 不会阻塞主进程
2. 不用线程 因为线程共享内存 需要加锁 进程共享内存但是只读 修改时发生写时复制 不用加锁

重写过程中主进程处理命令造成的数据不一致
解决方案
重写过程中再开辟一个aof重写缓冲区 redis执行完一个写命令后 会把命令同时写入aof缓冲区和aof重写缓冲区 子进程执行完重写后向主进程发送信号 主进程再把aof重写缓冲区的内容追加到aof文件中
## rdb
记录一个瞬间的内存数据 比aof更快（恢复）
save 手动 主线程
bgsave 手动 子进程
save m n 自动 子进程
执行快照时数据可修改 因为是子进程 写时复制
## 混合持久化
aof开始为rdb文件 后续aof重写缓冲区的为aof
优点 结合了2者的优点
缺点 aof可读性差 兼容性差
# redis集群
## 如何实现服务器高可用
多服务节点 如主从复制 哨兵模式 切片集群
### 主从复制
一主多从 读写分离 主负责写然后同步给从 从负责读
主从命令复制异步执行 主服务器在本地执行完写命令就会给客户端返回了 而不需要等到从服务器完成 所以无法实行主从强一致保证（主从数据时刻一致）
### 哨兵模式
监控主从服务器 提供主从节点故障转移
定时向所有服务器发送数据（心跳）主服务器下线后选择新的主服务器
### 切片集群 
分布式 类似磁盘阵列
使用hash槽处理数据和节点间的映射关系 而哈希槽和具体的节点之间的对应关系可以平均分配也可以手动分配
## 集群脑裂导致数据丢失
客户端向主服务器发送的写请求在主服务器上执行了 但是主从服务器之间的网络出现异常 哨兵选出了新的主服务器 原来的主服务器重新上线变成了从服务器 被新的主服务器的数据覆盖 客户端写入的数据丢失
解决方案 当主服务器连接到的从服务器数量小于每个值或者与从服务器之间的延迟大于某个值就禁止客户端的写操作
# redis过期删除与内存淘汰
## 过期删除策略
当我们对一个key设置过期时间 redis会将这个key和过期时间存储到过期字典中 当我们查询一个key的时候 redis会首先检查key在不在过期字典中 不在就正常读取 在就检查是否过期
redis采用惰性删除和定期删除的策略
### 惰性删除
不主动删除 从数据库访问key时如果过期再删除 给客户端返回null
优点 cpu占用少 缺点 内存浪费
### 定期删除
每隔一段时间就随机抽一定数量的key 删除其中过期的
流程
1. 从过期字典中随机抽20个
2. 删除其中过期的
3. 如果删除数量大于25% 重复操作
为了避免占用太多时间 默认不超过25ms
优点 一定程度上对cpu和内存的影响达到了平衡
缺点 难以确定时长和频率
## 持久化时对过期key的处理
### rdb
* 生成阶段 会进行过期检查 过期的不会进入rdb
* 加载阶段 主服务器会进行检查 从服务器不会 但是主从服务器会同步 所以一般对主从服务器都不会有影响
## aof
* 写入阶段 没被删除的过期键会被保留 删除后会向aof追加一个显式del命令
* 重写阶段 会进行检查 已过期的键不会被保存
## 主从模式对过期键的处理
从库不会对过期键进行任何处理 所以客户端能读到过期键 主库key到期会向从库的aof追加一条del命令
## redis内存满了会怎么样
运行内存达到最大阈值就会触发内存淘汰机制
## 内存淘汰策略有哪些
1. 不进行内存淘汰 到达最大阈值就报错 默认
2. 在设置了过期时间的键中随机淘汰
3. 在设置了过期时间的键中淘汰最先过期的 （ttl）
4. 在设置了过期时间的键中淘汰最久未使用的 lru
5. 在设置了过期时间的键中淘汰最少使用的 lfu
6. 随机淘汰任意键
7. 淘汰所有键中最久未使用的 lru
8. 淘汰所有键中最少使用的 lfu
## lru和lfu的区别
传统lru的实现基于链表 最新操作的键被移到表头 只要删除表尾的元素即可
缺点
1. 需要用链表管理所有的缓存数据 带来额外空间开销
2. 频繁链表移动操作耗时大
redis并没有采用这样的方式

redis采用了近似lru算法， redis的对象结构体中记录了最后访问时间 进行内存淘汰时 采用随机采样 随机选5个key 淘汰其中最久没有使用的 克服了上述两个缺点
但是lru无法解决缓存污染问题 比如一次读取了大量数据 数据只会被读取一次 这些数据就会留在redis缓存中很久
为了解决这个问题 引入了lfu
lfu会淘汰数据访问次数最少的
# redis缓存设计
## 如何避免缓存雪崩 缓存击穿 缓存穿透
### 避免缓存雪崩
大量缓存数据在同一时间过期
解决方案
1. 将缓存失效时间随机打散 比如在原有失效时间上加一个随机值
2. 设置缓存不过期 通过后台服务更新缓存数据
### 避免缓存击穿
热点数据过期
解决方案 前文提到的两种和
1. 互斥锁 降低并发 redis使用setnx设置一个状态位， 表示锁定状态 未获得互斥锁的请求 要么等待锁释放后读取 要么返回空值或默认值
2. 不给热点数据设置过期时间 由后台异步更新缓存 或者在热点数据快要过期前 通知后台线程更新缓存 重新设置过期时间
### 避免缓存穿透
访问的数据既不在缓存中也不在数据库中
一般有以下原因
1. 业务误操作 数据被误删除
2. 恶意攻击
解决方案
1. 限制非法请求 api入口处判断请求参数是否合理 恶意请求直接返回错误
2. 设置空值或默认值 针对查询的数据在缓存中设置默认值或者空值
3. 使用布隆过滤器快速判断数据是否存在 写入数据库时用布隆过滤器标记 缓存失效时查询布隆过滤器 不存在直接返回错误 这样大量查询只会查询redis和布隆过滤器
## 设计一个缓存策略 动态缓存热点数据
通过数据最新访问时间排名， 过滤掉不常访问的数据
具体实现 比如要求缓存top1000
1. 先用缓存做一个排序队列 保存1000个id 最近访问的靠前
2. 定期过滤掉最后200名， 再从数据库中随机读出200名加入队列
3. 当请求到达时 从队列获取id 命中再从缓存中读取具体信息并返回

在redis中使用zset 用zadd和zrange完成排序队列和获取200个商品的操作
## 常见缓存更新策略
共有三种
1. cache aside（旁路缓存）
2. read





