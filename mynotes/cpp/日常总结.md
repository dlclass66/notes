# 对多个变量同时赋值
错误示范
```cpp
 int a, b, c = 10;//这样只会给c赋值
```
正确方式
```cpp
int a, b, c;
a = b = c = 10;
```
参考链接 <https://blog.csdn.net/weixin_45483780/article/details/120324247>
# 编译预处理
* 以#开头的命令 告诉编译器 
* 一般编译器简单的复制粘贴
# static 
* 类（结构）的静态成员
类的静态成员存储于任何对象之外 只存在于类 在实例之间共享 改变一个就改变了所有
* 类外 只在一个cpp文件有效的变量
* 大型项目尽量使用static 函数和变量
* extern关键字可以告诉编译器在外部寻找变量
## 类的静态成员
* 一般在类外定义 不重复static关键字
* 一般使用作用域运算符直接访问
```cpp
#include<iostream>
class circle{
    static double s_pi;
    double r;
    void print_pi(){
        cout << s_pi;
    }
    void print_r(){
        cout << r;
    }
}
double circle::pi = 3.14//类外定义与赋值 在类外访问也使用此形式
static print_r(circle cir){
    cout << cir.r;
}//等价于类中函数
```
* 静态函数不能访问类中非静态变量（静态函数的参数必须完全为静态）
* 类中的非静态函数实际相当于类外的静态函数通过实例访问类中成员
## 函数或者{}中的静态局部（本地）变量
* 生存期于程序一致 但是只能在函数中访问 
```cpp
void fun(){
    static i = 1;
    i++;
}
fun();
fun();//此时i=3
```

# 同一个函数的反复定义
比如头文件里面包含了一个函数的定义 在多个.cpp文件都include了这个头文件 
解决方式 
可以把函数声明放在头文件中而把函数定义只放在一个.cpp文件中
# 查看占用内存的大小 sizeof
```cpp
sizeof (int);//以byte字节为单位
double a = 0;
sizeof(a);
```
# 头文件通常用来存放函数声明
```cpp
#include <iostream>
#include "main.h"
```
<> 和 “”的区别
<>一般是系统位置 “”则表示相对位置
参考 <https://blog.csdn.net/ROseeattimoo/article/details/126225227>
c标准库一般有.h扩展名 cpp则没有
# #pragma
在头文件中的预处理指令 防止同一个.cpp文件多次重复include同一个头文件
也可用以下方式替代
```cpp
#ifndef _MAIN_H//大写避免重名
#def _MAIN_H

#endif
```
# 两个16进制位表示一个byte（8个bit）
# math.h
sqrt() 开方 pow()平方
```cpp
#include <math.h>
double a = sqrt(4);//4开方
double a1 = pow(4, 0.5);//4开方
double b = pow(3, 2);//3的平方
```
# 函数的声明和定义
* 函数需要先声明后使用 而定义可以在任何地方
# 使用异或（^）交换
```cpp
int a = 2;
int b = 3;
void swap(int a, int b){
    a ^= b;
    b ^= a;
    a ^= b; 
}
swap(a, b);
```
原理 a ^ b = b ^ a  
a ^ b ^ b = a 
# 容器 vector
智能链表 方便延长
（延长就是创建一个新的 删除旧的）
连续存储 所以最好存对象而不是指针
## vector作为函数参数
如果需要修改vector中的元素 最好以引用的方式传入 如果是数组无需这样操作
```cpp
vector <int> a = {1,2};
void swap(vector <int> &a){
    a[0] ^= a[1];
    a[1] ^= a[0];
    a[0] ^= a[1];
}
swap(a);//a会变为{2，1}
int arr[2] = {1, 2};
void swap(int arr[]){
    a[0] ^= a[1];
    a[1] ^= a[0];
    a[0] ^= a[1];
}
swap(arr);//相同的效果 但是数组无需使用参数传递
```
## 在vector末尾插入 .push_back()
```cpp
vector <int> vet;
vet.push_back(1);
```
建议使用emplace_back代替 更高效
## 通过reserve减少拷贝次数
使用reserve提前为vector申请足够的空间
# 字符串的输入
使用getline函数 
```cpp
#include<iostream>
#include<string>
using namespace std;
int main(){
    string str;
    getline(cin, str);
}
int a;
a = (int)str.length();//str.length()结果为unsigned
```
参考链接<https://blog.csdn.net/fsspringalex/article/details/105089478?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167808038716782427462818%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=167808038716782427462818&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-105089478-null-null.142^v73^insert_down4,201^v4^add_ask,239^v2^insert_chatgpt&utm_term=cpp%E8%BE%93%E5%85%A5%E5%AD%97%E7%AC%A6%E4%B8%B2&spm=1018.2226.3001.4187>
# cpp项目文件结构管理
可以把源代码（.cpp）都放在一个文件夹 中继文件（.obj）放在一个文件夹 可执行文件（.exe）放在一个文件夹
# 指针
```cpp
int i = 5;
int j = 6;
int* ptr_i = &i;
int* ptr_j = &i;
*ptr_i = 6;//指针读写所指
ptr_i = ptr_j;//指针更改所指对象
int** ptr = &ptr_j;//双重指针 
```
# new 和 delete
申请内存和释放内存
new在创建类的时候会调用构造函数 底层是 malloc
```cpp
new int* ptr_arr = new int[20];
delete[] ptr_arr;//new有框delete也有
```
尽量将变量存储在栈中
# 值传递 引用传递 指针传递
当我们需要在函数内部改变外部变量的值时 需要引用传递
```cpp
void add_1 (int& a){
    a++;
}//引用传递
void add_1 (int *a){
    （*a）++;//运算优先级
}//指针传递
int i = 1;
add_1(i);//这样可以使i加一
add_1(&i);
```
* 尽量采用引用传递
# class和struct 与面向对象编程
类和结构几乎只有默认可见性不同 class默认private struct默认public struct更偏向c
# C++中数组、链表和vector等容器之间的区别
参考链接<https://blog.csdn.net/FX677588/article/details/52794015>
# enum 枚举 用来管理一些整数
```cpp
enum example ：int //选择类型
{
    A, B, C
}//默认为整数 从0开始
example size = A;
```
## 类中的enum
# constructor 构造函数
帮助对类进行初始化
```cpp
class example{
    int x, y;
    example() = delete;//禁止实例访问构造函数
    example(){
        x = 0;
        y = 0
    }
    example(int a, int b){
        x = a;
        y = b;
    }//重载
    ~example(){}//析构函数
}
example e1;//自动调用构造函数进行初始化
example e2(2, 3);//调用有两个int参数的构造函数
```
# 析构函数 在销毁实体时调用
* 一般不会手动调用
[示例见上文](日常总结.md#constructor-构造函数)
# 继承 避免代码复用（增加易维护性）
```cpp
class fa{
public:
    int x,y;
    void print_x(){}
};
class son : public fa{
public const char* name;
};//son可以继承fa中的public部分
```
# 虚函数(有一定性能开销) 在子类中对父类方法override
* 多态
```cpp
class fa{
public:
    virtual void print(){}
};
class son : public fa{
public:
    void print() override{

    }//显式标记 提醒编译器
};
int main(){
    fa fa1;
    son son1;
    void print_m(fa& fa1){
        fa1.print;
    }
    print_m(fa1);//会使用fa里的print函数
    print_m(son1);//会使用son里的print函数
}
```
## 纯虚函数
* 接口只描述类的行为和功能 不提供具体的实现方式（抽象类）无法实例化
* 含有至少一个纯虚函数的类就是抽象类
* 具体实现由其子类实现
```cpp
class get_name{
public: 
    virtual void getname() = 0;
};
class a : public get_name{
    void getname() override{}
};//可以由此设计一个功能 每个类可以打印自己的名称
```
# 访问控制（可见性 visibility）
* private > protect > public
## private 
* 只能在类内访问 或者是标记为友元（friend）的类或者函数中访问（将函数声明放在类中 并在前面加上关键词 friend）
## protected
* 可以在类和其子类中访问
## public
* 可以在任意地方访问 通常是一些接口函数
# array 数组
* cpp 11引入了标准数组 更加安全可靠
* 堆栈中（stack）的数组可以使用sizeof 堆（heap）中的不可以 但是堆中的可以手动控制生存周期
```cpp
#include<array>
array <int, 5> st_arr;
int size1 = st_arr.siza();
int arr[5] row_arr;
int size2 = sizeof(row_arr) / sizeof(int);
int* arr_heap = new int[5];
delete[] arr_heap;
```
# string 字符串
* 约等于char*
* 作为函数参数时尽量引用传递 不改变可以传const
* 用+可以连接两个string
# 字符串字面值
* 类似"hello" 实际是字符数组（char array）
* 不能通过char* 修改 所以 最好用 const char*
* 可以分行书写
```cpp
cout << "hello"
        "world" << endl;
```
* 实际以\0结尾
# mutable
* 在lambda使用（较少）
* 在类中对变量使用（较多）[示例](基础知识.md#const)
# 成员初始化列表
* 相比于构造函数更有优势
```cpp
class example{
    int x,y;
    example(int a)
        : x(10) , y(a)//顺序按变量在类中的定义顺序
    {
        cout << x <<endl;
    }
};
```
# 三元表达式
* 在分支较少时提升代码可读性
```cpp
int x = 3;
int y = 5;
x = y > 5 ? 1 : 0;//等价于下面
if(y > 5){
    x = 1;
}else{
    x = 0;
}
```
# 类实例化为对象的两种方式
* 可以用堆栈的情况下用堆栈
* 不行的情况用指针和new关键词使用堆
# 隐式类型转换和强制类型转换
## 隐式
* 只能转换一次 
* 可以直接调用构造函数进行转换 但可能会降低代码可读性
* 可以通过在构造函数前加上explicit关键字禁用
# 运算符和运算符重载
* 适当使用可以使代码可读性更强
* 最好同时提供重载和函数 重载可以直接调用函数 
* 常见的重载比如 "+" "-" "<<" 让我们对类的操作看起来跟操作基本数据类型一样
```cpp
class vector_2{
private:
    int x, y;
public:
    vector_2(int x, int y)
    :x(x), y(y){}
    vector_2 add(const& other){
       return vector_2(x + other.x, y + other.y);
    }
    vector_2 operator+ (const& other){
        return add(other);
    }//双目运算符的重载(一个参数) 单目就没有参数
}
ostream& operator<<(ostream& stream, &vector_2& other){
    stream << other.x << ',' << other.y << endl;
    return stream;
}//对<<的重载
```
参考链接<https://blog.csdn.net/lu_embedded/article/details/121599696?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167823881516800227452454%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=167823881516800227452454&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-121599696-null-null.142^v73^insert_down4,201^v4^add_ask,239^v2^insert_chatgpt&utm_term=cpp%20%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD&spm=1018.2226.3001.4187>
# this指针
* 在类中指向自己 是一个const *（不能改变所指对象）
# 生存周期
## 存储在堆栈中的变量的生存周期
以{}为界（作用域）
# 智能指针
使内存管理更为智能(相比于直接使用new和delete更为安全)
## unique_ptr （不能复制所以unique）
让存储在堆上的对象像存储在堆栈上的对象一样 超出作用域自动删除
可以手动实现一个uniqueptr
原理 
unique_ptr本身是一个存储在堆栈上的指针 而其析构函数包含delete 在超出作用域时会调用析构函数
```cpp
class unique_ptr{
    int* ptr;
    unique_ptr(int* a){
        ptr = a;
    }
    ~unique_ptr(){
        delete ptr;
    }
}
int main{
    {
        unique_ptr ptr = new int*;
    }
}
```
### 正式的unique_ptr
```cpp
#include<memory>
class entity{
    entity(){

    }
}
unique_ptr <entity> ptr = make_unique <entity> ();//推荐的方式
unique_ptr <entity> ptr1(new entity());//不能使用 = 因为类型转换被禁用了
shared_ptr <entity> s_ptr = make_shared <entity>();//共享指针
```
## shared_ptr
可以共享的智能指针 通过引用计数智能判断何时回收
## weak_ptr
可以共享 但是不会主动使引用计数器计数的指针 
# 复制（恰当使用提升性能）
* 在不需要拷贝的时候不进行拷贝可以有效提升性能
(尽量将函数参数设置为常量引用)
* 涉及指针的拷贝很多时候只是浅拷贝（只是复制了一个指针指向被复制的指针指向的对象）很容易引发错误
* 使用拷贝构造函数进行对象的深拷贝
```cpp
class string{
    char* m_buffer;
    unsigned int m_size;
    string(const& string other){
        
    }//拷贝构造函数
};
```
# ->
# 库 libary
一般会有头文件和库 库又分为静态库和动态库 一般来说静态库更快
静态连接需要告诉linker.lib位置
动态连接需要把.dll文件放在和.exe一个文件夹
# vs
$(SolutionDir) 项目所在文件夹
# 需要同时返回多个值的函数
* 可以将想要返回的作为引用传进去
* 可以构造一个结构 返回结构
# 模板 template
让几乎相同的函数不用反复重载
让需要常数的地方可以暂时不用
```cpp
template <typename T, int N>
class example{
    T N;
    void print(){
        cout << N;
    }
};
int main(){
    example e(5);
    e.print;
}
```
# 宏 预编译阶段的文本替换
## #define
 #define a b 预编译把程序中的a都替换成b
可以用宏在release中隐藏代码




