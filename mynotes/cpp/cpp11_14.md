# 参数数量不定的模板
可以用来递归（需要设计对终止条件的处理）当要一个一个处理很多类型不一样的对象时很有用
如果一个函数参数是一个参数包 它的重载参数是一个参数和一个参数包 后者是前者的特化版本
还可以利用sizeof...() 确定正在处理的是第几个参数
```cpp
#include<iostream>
using namespace std;
void print() {}//后面要调用所以应该把声明或者定义放在前面
template<typename T, typename... Args>//一个template只对接下来的一个函数有效
void print(const T& t, const Args&... args) {
	std::cout << t << std::endl;
	print(args...);
}//特化版本
template<typename... Args>
void print(const Args&... args) {
	std::cout << '0' << std::endl;
}//泛化版本 此例中不会调用
int main() {
	print(1, 1.2, 3, "hello");
	std::cin.get();
}
```
可以用来重写printf 因为打印的类型多样 
# 统一的初始化方法
在后面直接加{} 底层是生成一个初始化列表 底层是一个array 会将里面的值一个一个传进函数（也有一些函数是以初始化列表为参数）
不允许窄化 比如用double给int赋初值
标准库的容器和算法很多都支持了初始化列表作为参数（可以传进相同类型的不限个数的参数了）
# explicit 在多参数构造函数的作用
阻止使用初始化列表（参数个数与构造函数一致）进行隐式类型转换
# 默认和删除
## 4种重要函数
1. 构造函数
2. 拷贝构造函数
3. 拷贝赋值函数
4. 析构函数
没有指针的类这几种函数都可以使用默认的 有指针的一般需要自己写
### = default
显式声明使用默认 也可能是已经定义了有参数的构造函数 但因为有继承关系 希望使用没参数的构造函数（如果不写就不会使用无参数的默认构造函数）
### =delete
用来禁止调用拷贝函数
可以写一个这样的父类 通过继承使子类也拥有这样的性质
# 模板别名
使用using关键字 给模板一个别名
比如我们希望容器都使用我们自己的分配器
```cpp
template<typename T>
using vec = vector<T, myalloc<T>>;
vec<int> myvec;
```
# 类型别名
使用using 关键字 跟typedef类似
```cpp
using func = void(*)(int, int);
typedef void(*func)(int, int);//func是一个有两个int类型参数 返回类型为void的函数指针的类型
void example(int x, int y){}
func a = example;
```
# final
用来表示类不会被继承 或者虚函数不会被覆写 在名称括号后面显式声明
# noexcept
在函数名称括号后显式声明
告诉编译器这个函数不会丢出错误信息 
在移动构造函数(在需要大量复制的容器中存放的对象的类)中需要使用
还可以用（）放入条件 告诉编译器在这个条件下不会抛出异常
# decltype
用来得到对象的类型 
主要有三种用法
指定返回类型
```cpp
auto func (int x) -> decltype(x) {

}
```
在模板编程中 传入一个对象就可以得到其类型
在使用lambda时表示其类型
# lambda表达式
先当与一个匿名的类函数 但是没有默认构造函数
是内联函数 可以像函数指针一样使用他 
```cpp
auto func = []{cout << "hello world"};
func();
```
默认使用值传递 可以使用&表示是引用传递
主要用途是对标准库所提供的东西进行小改动 比如写一个自己的比较条件
# tuple
其实是一系列的继承 利用可变模板参数 最下面的子类分离出第一个参数 剩下的创建一个父类 递归 也可以用复合的方式实现
```cpp
template<typename... Head> class tuple{};
template<> class tuple{};
template<typename Head, typename... Tail>
class tuple< Head, Tail...> private : tuple <Tail...>{
	typedef tuple<typename... Tail> inherited;
public :
	tuple() {};
	tuple(Head v, Tail... vtail)
		:m_head(v), inherited(vtail...)//这里会调用父类的构造函数
		{}
	Head head() {return m_head}
	inherited& tail() {
		return *this;
	}//这里完成了一次转型 子类转换为了父类
protected:
	Head m_head;
}
tuple<int, double> t(1, 3.14);
t.head();
t.tail().head();

template<typename... Head> class tuple{};
template<> class tuple{};
template<typename Head, typename... Tail>
class tuple<Head, Tail...> {
	typedef tuple<typename... Tail> composited;
public :
	tuple() {};
	tuple(Head v, Tail... vtail)
		:m_head(v), m_tail(vtail...){}
	Head head() {return m_head}
	composited& tail() {
		return m_tail;
	}
protected:
	Head m_head;
	composited m_tail;
}
```
 
 