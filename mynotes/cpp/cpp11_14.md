# 参数数量不定的模板
可以用来递归（需要设计对终止条件的处理）当要一个一个处理很多类型不一样的对象时很有用
如果一个函数参数是一个参数包 它的重载参数是一个参数和一个参数包 后者是前者的特化版本
```cpp
#include<iostream>
using namespace std;
void print() {}//后面要调用所以应该把声明或者定义放在前面
template<typename T, typename... Args>//一个template只对接下来的一个函数有效
void print(const T& t, const Args&... args) {
	std::cout << t << std::endl;
	print(args...);
}//特化版本
template<typename... Args>
void print(const Args&... args) {
	std::cout << '0' << std::endl;
}//泛化版本 此例中不会调用
int main() {
	print(1, 1.2, 3, "hello");
	std::cin.get();
}
```
# 统一的初始化方法
在后面直接加{} 底层是生成一个初始化列表 底层是一个array 会将里面的值一个一个传进函数（也有一些函数是以初始化列表为参数）
不允许窄化 比如用double给int赋初值
标准库的容器和算法很多都支持了初始化列表作为参数（可以传进相同类型的不限个数的参数了）
# explicit 在多参数构造函数的作用
阻止使用初始化列表（参数个数与构造函数一致）进行隐式类型转换