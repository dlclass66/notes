# 标准库和标准模板库
标准库里面大部分是标准模板库（stl） stl有六大部件 标准库由头文件的形式呈现 被封装在std命名空间中
## 六大部件
容器 分配器（为容器分配内存） 算法 迭代器（类似指针） 适配器 仿函式
## 标准库的前闭后开迭代器
迭代器头（.begin()）指向第一个 位（.end()）指向最后一个的下一个
# 容器
大致可以分为两种 顺序容器和关联式容器
## 顺序容器
* array（数组） 
* vector（可以单向向后长大的数组）
* deque（可以双向长大的数组）底层是分段（buffer）连续的 每次扩充一个buffer
* list（双向链表）链表中包含指向自己这种类型的指针 其实是双向环状链表 中间有一个空的是end所指向的 为了符合前闭后开的原则
* forward-list(单向链表)只能push_front 不能输出大小和最后一个元素 其实是单向环状链表
* stack和queue的底层是deque （更像是一种容器适配器而不是容器）也可以选择list 不提供迭代器
### array 
有两个参数 第一个是类型 第二个是大小 没有构造函数和析构函数
### vector
每次内存不够就两倍增长
含有三个指针（迭代器）一个是开始 一个是结束 一个是现在最长能储存到的地方
迭代器就是原始指针
### deque 
在内存中是分段连续的 使用一个vector当作控制中心 里面存储指针指向buffer 每个buffer大小一样
迭代器有4个部分 一个是cur 一个是buffer的第一个 一个是buffer的最后一个 一个是指向控制中心的指针 由于是两端可扩展 插入元素时会向元素较少的那个方向扩展
迭代器重载-=的时候可以直接调用+=
+=会先判断最后会在哪个buffer而不是重复调用++
## 关联容器
* set和multiset 存储值 快速查找 底层是红黑树
* map和multimap 存储key 和value 用key快速查找value 底层是红黑树 放进去的是pair
* map和set的unordered版本 底层是哈希表 冲突用链表解决 篮子个数要大于元素个数 增长时大约是增长两倍
## 红黑树
是高度平衡的二叉搜索树 一些情况下可以有重复元素
# 算法
所有算法最终都是比大小 可以自己设计compare函数替代默认的条件或者使用运算符重载
## 查找 find
顺序查找 出来的结果是一个迭代器
## sort 排序
有些容器可能有自己的sort 也有全局的sort 此情况建议使用容器的sort
# 分配器
一般不会直接使用分配器 默认使用标准分配器 底层是malloc 使用operator new 调用 没有特殊设计 会造成大量空间浪费 所以几乎不被编译器使用
一种优化思路是减少malloc的使用 由于容器都是存储的同样大小的元素 可以一次malloc一大块内存 分割为小块小块的内存存储容器的对象 
# 面向对象和泛型的区别
面向对象类中含有元素和对其操作的方法 而泛型则将元素和操作其的方法分开 通过迭代器进行联系
# 迭代器
一般会有几个typedef（至少5个） 会重载几个运算符 ++i 和i++通过重载时有无参数区分 前者没有 后者有一个 一般后者会调用前者 注意表达式的顺序
## 5个问题和traits 
五个问题分别为
* 迭代器类型
* 迭代器最大间隔类型
* 容器的数据类型
* 指针
* 引用
(后两种几乎不会被调用)
迭代器可能是一个类 可能只是原始的指针 这个时候就需要添加一个中间层区分两种情况 使用偏特化即可 如果传进来的是指针或者指向常量的指针 说明是原始指针 对这种情况进行特化 由traits进行包装