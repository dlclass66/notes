# 标准库和标准模板库
标准库里面大部分是标准模板库（stl） stl有六大部件 标准库由头文件的形式呈现 被封装在std命名空间中
## 六大部件
容器 分配器（为容器分配内存） 算法 迭代器（类似指针） 适配器 仿函式
## 标准库的前闭后开迭代器
迭代器头（.begin()）指向第一个 位（.end()）指向最后一个的下一个
# 容器
大致可以分为两种 顺序容器和关联式容器
## 顺序容器
* array（数组） 
* vector（可以单向向后长大的数组）
* deque（可以双向长大的数组）底层是分段（buffer）连续的 每次扩充一个buffer
* list（双向链表）链表中包含指向自己这种类型的指针 其实是双向环状链表 中间有一个空的是end所指向的 为了符合前闭后开的原则
* forward-list(单向链表)只能push_front 不能输出大小和最后一个元素 其实是单向环状链表
所以有点像栈 后进的在前面 （如果用for遍历的话）
* stack和queue的底层是deque （更像是一种容器适配器而不是容器）也可以选择list 不提供迭代器
### array 
有两个参数 第一个是类型 第二个是大小 没有构造函数和析构函数
### vector
每次内存不够就两倍增长
含有三个指针（迭代器）一个是开始 一个是结束 一个是现在最长能储存到的地方
迭代器就是原始指针
### deque 
在内存中是分段连续的 使用一个vector当作控制中心 里面存储指针指向buffer 每个buffer大小一样
迭代器有4个部分 一个是cur 一个是buffer的第一个 一个是buffer的最后一个 一个是指向控制中心的指针 由于是两端可扩展 插入元素时会向元素较少的那个方向扩展
迭代器重载-=的时候可以直接调用+=
+=会先判断最后会在哪个buffer而不是重复调用++
## 关联容器
* set和multiset 存储值 快速查找 底层是红黑树 不能通过迭代器改key（底层使用const） 有三个模板参数第一个是key的数据类型 第二个是比较大小的方式（有默认）第三个是内存分配方式（有默认）
* map和multimap key和data合成一个pair（value）放进去 可以通过迭代器修改data 不可以修改key（const）multi是指key可以重复 使用时指定key 和data的类型即可 map还可以使用[]做插入  
* map和set的unordered版本 底层是哈希表 冲突用链表解决 篮子个数要大于元素个数 增长时大约是增长两倍
## 红黑树
是高度平衡的二叉搜索树 一些情况下可以有重复元素 最长路径不超过最短的2倍
迭代器按默认顺序(中序 左中右)遍历 结果已经被排序（从小到大）
效率高 可在lgN的复杂度实现查找增加删除
红黑有以下性质
* 节点是红色或黑色
* 根是黑色
* 叶子节点（外部节点，空节点）都是黑色，这里的叶子节点指的是最底层的空节点（外部节点），下图中的那些null节点才是叶子节点，null节点的父节点在红黑树里不将其看作叶子节点
* 红色节点的子节点都是黑色
* 红色节点的父节点都是黑色
*从根节点到叶子节点的所有路径上不能有 2 个连续的红色节点
* 从任一节点到叶子节点的所有路径都包含相同数目的黑色节点
参考链接 <https://blog.csdn.net/cy973071263/article/details/122543826?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167896626916782427414342%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=167896626916782427414342&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-122543826-null-null.142^v74^insert_down38,201^v4^add_ask,239^v2^insert_chatgpt&utm_term=%E7%BA%A2%E9%BB%91%E6%A0%91&spm=1018.2226.3001.4187>
容器提供了两种插入方式 一个是unique(不允许重复) 一个是equal(允许重复)
节点有key和data 合起来叫value
## hashtable
内部有vector和链表 当元素个数超过bucket的个数时 bucket变成其原来的两倍（最近的质数）哈希值除以篮子个数取余的结果就是要放进的篮子的编号 
模板参数有key的类型 value的类型 哈希函数（如何将对象映射为哈希值）如何从value中提取key 如何判断key相等 和分配器(有默认值) 
节点有数据和指向下一个节点的指针
迭代器有指向节点的指针和指向控制中心的指针(vector相当于控制中心 有指向节点的指针)
标准库有cstr的哈希函数（类似于将字符串考虑为一个5进制数）
# 算法
所有算法最终都是比大小 可以自己设计compare函数替代默认的条件或者使用运算符重载
算法会根据迭代器类型进行特化 提高效率
标准库中的算法 统一接口 前两个参数是两个迭代器 表示范围
很多算法都会有多个重构 有的可以传入仿函数或函数（或者lambda表达式）当作条件
## 查找 find
顺序查找 出来的结果是一个迭代器
## sort 排序
有些容器可能有自己的sort 也有全局的sort 此情况建议使用容器的sort
## 二分查找
必须要先排序 底层是调用lower_bound(找到不影响顺序的最早插入位置)
## copy
参数是被拷贝对象的起始迭代器 终止迭代器 拷贝到的地方的起始迭代器 基本操作就是一个一个赋值 
有各种特化版本
## insert
各个容器基本都会提供 两个参数的版本 第一个是迭代器 第二个是需要插入的内容 从迭代器所指的位置开始插入（插入完毕后的第二个参数的位置是插入的内容的起始位置）
## hash
一个万用的hash可以使用可变数量的模板参数处理 使用每一个参数所对应的对象对seed进行处理 最后seed就是需要的hash值 可以把hash写成一个类函数
# 分配器
一般不会直接使用分配器 默认使用标准分配器 底层是malloc 使用operator new 调用 没有特殊设计 会造成大量空间浪费 所以几乎不被编译器使用
一种优化思路是减少malloc的使用 由于容器都是存储的同样大小的元素 可以一次malloc一大块内存 分割为小块小块的内存存储容器的对象 
# 面向对象和泛型的区别
面向对象类中含有元素和对其操作的方法 而泛型则将元素和操作其的方法分开 通过迭代器进行联系
# 迭代器
一般会有几个typedef（至少5个） 会重载几个运算符 ++i 和i++通过重载时有无参数区分 前者没有 后者有一个 一般后者会调用前者 注意表达式的顺序
迭代器有五种类型（也存储在上文的其中一个typedef中）随机存取型（连续）（vector deque array） 双向型（双向链表 set map） 单向型（单向链表）（哈希set 哈希map）输入型 输出型
## 倒转迭代器（适配器）
rbegin（）end（）的前一个
rend（）begin（）的前一个 反向遍历
底层是一个对应的正向迭代器
关键是对*的重载 返回的是所对应的正向迭代器减一
其余操作与正向迭代器正好相反
## 插入迭代器（适配器）
inserter（）需要两个参数 第一个是容器对象 第二个是起始迭代器
可以对copy进行改造 使其变成插入
原理是将copy中的=重载 通过迭代器调用容器的insert操作 实现插入
## ostream迭代器（适配器）
需要一个模板参数 需要输出的类型 参数两个 一个是使用的ostream对象 比如cout 另一个是分隔符(字符串)
和copy配合使用 重载= 表示把被拷贝对象丢到cout里面（使用<<）然后再丢分隔符 * ++ --重载为无意义
```cpp
ostream_iterator<int> o(cout, ",");  
```
## istream迭代器（适配器）
需要一个模板参数 需要输入的类型 需要一个参数 使用的istream对象 如果缺省的话就是eos（表示流结束）当创建这个迭代器的时候已经在等待读入数据了
istream_iterator<int> eos;
istream_iterator<int> il(cin);
## 综合用例
```cpp
#include <iostream>
#include <vector>
#include <string>
#include <iterator>
#include <algorithm>
using namespace std;

int main() {
	vector<int> vec1;
	vector<int> vec2;
	for (int i = 0; i < 5; i++) {
		vec1.push_back(i);
		vec2.push_back(10 * i);
	}
	auto it = vec1.begin() + 1;
	copy(vec2.begin(), vec2.end(), inserter(vec1, it)); //注意 使用过inserter后 不能再使用it了
	istream_iterator<int> inp(cin), eos;
	copy(inp, eos, inserter(vec1, vec1.begin() + 1));
	vector<int> vec3(inp, eos);
	ostream_iterator<int> op(cout, ",");
	copy(vec1.begin(), vec1.end(), op);
	while (1);
}

```
## 5个问题和traits 
五个问题分别为
* 迭代器类型
* 迭代器最大间隔类型
* 容器的数据类型
* 指针
* 引用
(后两种几乎不会被调用)
迭代器可能是一个类 可能只是原始的指针 这个时候就需要添加一个中间层区分两种情况 使用偏特化即可 如果传进来的是指针或者指向常量的指针 说明是原始指针 对这种情况进行特化 由traits进行包装
# typename关键字
在模板中 typename和class意思意思相同
typename还可以告诉编译器其后面的表达式表示的是一个类型（一般是含有：：的类型） 在含有模板的时候这很有用 因为没有实例化之前编译器很难判断到底是类型还是变量
# 仿函数
标准库中的仿函数需要继承一些typedef作为接口 这样方便适配器对其进行改造
# 适配器
一般包含一个需要改造的对象 可以修改一些函数的名称 或者减少或增加一些函数
适配器如果还想被改造 也可以继承一些typedef作为接口
## bind
使用占位符绑定函数参数
可以绑定函数 仿函数 成员函数 成员数据 后两种需要占位符1（_1 为this指针 也就是对象名）默认返回值为函数返回值 可以使用<>指定返回类型
# 辅助函数
对于一些不便于给出模板参数的类 可以设计一个辅助函数 使用函数的实参推导 里面返回一个所要使用的类的临时对象
# trivial
不重要的
# type_traits
是一系列的typedef 自己写的类（不用自己写typedef） 标准库中的各种类都可以使用 表现了其的一些性质 简单的通过特化偏特化实现
# cout
是属于ostream的一个对象 对<< 有很多重载
