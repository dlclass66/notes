
# 硬件结构

## cpu是如何执行程序的

### 冯诺依曼模型

计算机基本结构为5个部分 运算器，控制器，存储器，输入设备，输出设备

### 内存

基本单位byte字节 1byte = 8 bit（位）

### cpu

32位处理器一次处理4个字节（32位） 64位一次处理64位
32位最大操作4g内存 （2^32 byte）
软件的位宽指指令的位宽
一般64位的电脑可以运行32位的程序 反之则不行
常见寄存器

1. 通用寄存器 用来存放需要计算的数据
2. 程序计数器 存储下一条指令的地址
3. 指令寄存器 存储正在执行的指令

### 总线

用于通信
有以下几种

1. 地址总线 用于指定地址
2. 数据总线 用于读写数据
3. 控制总线 用于发送和接收数据

### cpu执行程序的大致过程

读取程序计数器对应的指令存入指令寄存器， 程序计数器自增（增大多少取决于cpu的位数） cpu执行指令寄存器中的指令 然后继续第一步
数据和指令在内存中是分开存放的 指令放在正文段 数据放在数据段
现代cpu多采用流水线的方式执行指令 一条指令被分为4个阶段 称为4级流水线

1. fetch cpu通过程序计数器读取指令
2. decode 对指令进行解码
3. execution 执行指令
4. store 将计算结果回写寄存器或者将寄存器的值写入内存
这4个阶段称为指令周期

### 指令类型

1. 数据传输
2. 运算
3. 跳转（用来实现条件分支 函数调用等）
4. 信号类型（比如中断trap）
5. 闲置（执行后cpu空转）

### 执行速度

cpu参数有时钟频率 表示一秒cpu能完成的基本动作的数量 但一条指令不一定只对应一个基本动作

## 磁盘与内存

### 存储器结构

离cpu由近到远 速度由快到慢 容量由小到大 寄存器 cpu cache（l1, l2, l3）内存 硬盘
32位cpu中大多数寄存器可以存储4字节 64位中大多数可以存储8字节
l1缓存通常分为指令和数据两个部分 每个核心都有 l2缓存每个核心都有 l3缓存通常多个核心共用
cpu并不会直接和每一种存储设备打交道 每种存储设备只和其相邻的设备交互 相当于层层缓存

## 如何写出让cpu运行更快的代码

对于计算密集型的程序来说 cpu运行效率很重要 让cpu计算所需要的数据能尽可能的在cpu cache中而不是内存中可以提高效率

### cpu cache的数据结构和读取过程

cache line（缓存块）是cpu从内存读取数据的基本单位 由标志（tag） 和数据块（data block）组成
cpu读取数据时 会先访问cache 没有命中再访问内存 这里就存在一个问题 cpu如何确定要访问的数据在不在cache中
最简单是使用直接映射 内存块对应的cache line由取模决定 唯一确定 但是这样可能出现多个内存块映射到同一个cache line上 为了区别不同的内存块 在对应的cache中还会存储一个tag 而cpu从cache中读取数据时 并不是读取整个cache 而是读取数据片段 （字word）这就需要一个偏移量

### 提高数据命中率

连续的访问 可以提高缓存命中率

### 提高指令命中率

分支中有规律的话 cpu会提前预测 这样也可以提高命中率

### 多核

由于l1 l2 不是多核心共享的 所以对于计算密集型 为了让缓存命中率更高 最好限制在一个核心上运行

## cpu缓存一致性

### cpu cache的数据写入

数据写入cache 导致内存与对应的cache中的数据不同 所以必须要把cache中的数据同步到内存中
有以下两种方法

1. 写直达（write through）
2. 写回（write back）

#### 写直达

最简单的方法 把数据同时写入内存和cache中
写入前如果数据已经在cache中了 就先更新cache 再写到内存中
如果没有在cache中 就直接把数据更新到内存里
直观 简单 但问题是每次操作都要写回到内存 性能受影响

#### 写回

当发生写操作时，新的数据仅被写入cache block中 只有当被修改过的cache被替换时才需要写到内存中 减少了数据写回内存的频率
具体做法

* 当cpu发生写操作时 如果cache里面有需要修改的数据 则修改 然后标记为脏
* 如果对应的cache存储的是其他内存块 这个时候就需要替换了 如果是脏的就写回内存 否则就不需要 然后把要写入的数据读取到cache中 修改并标记为脏

### 缓存一致性

如果使用写回策略 多核心操作同一变量就会出现问题 比如一个核心执行了i++ 只更新了cache而没有写回内存 另一个核心读取到的i的值就是错误的
要解决这一问题就需要同步不同核心的缓存 需要以下两点

1. 某个核心的cache数据更新需要传播的其他核心（写传播 write propagation）
2. 某个核心对数据的操作顺序，必须在其他核心看起来一样 事务串行化（transaction serialization） 比如核心a和b同时更新了i 传播到cd核心 而cd中ab更新顺序不同 就会产生错误
所以第二点需要锁 如果两个核心的cache有相同数据 那么对于这个相同数据的更新 需要拿到锁才能进行

### 总线嗅探

为了实现写传播 某个核心更新了cache需要广播 每个核心都会监听总线上的广播事件 如果有对应数据在自己的cache中 就更新 这种方法很简单 但是会加重总线的负担 也无法实现事务串行化

### mesi协议

基于总线嗅探机制 实现了事务串行化 用状态机制降低了总线带宽压力 做到了缓存一致性
用4个状态标记了cache line

1. 已修改 就是脏数据 修改也无需广播
2. 独占 干净数据 并且只有一个cache中有 可以自由操作 不需要通知其他核心 其他核心从内存中也读取了同样的数据就变成共享
3. 共享 干净数据 在多个cache中有 修改时需要广播 把其他cache中的相同数据设置为无效 然后再更新 变为已修改
4. 无效 数据已经失效 不可读取
只有修改3状态的数据才需要广播 减低了总线负担
运用了有限状态机的思想

## cpu是如何执行任务的

### catch伪共享

多个线程同时读写同一个cache line的不同变量，导致cpu cache失效的现象 （cache line会被标记为共享）性能受到影响

### 避免方法

对于多个线程共享的热点数据 即经常修改的数据 要避免恰好在一个cache line中
linux中有一个宏（__cacheline_aligned_in_smp）用于解决伪共享问题 在多核cpu中可以让变量对齐cache line 使其不会出现在同一个cache line中 这样就用空间换了时间
应用层也有解决办法 可以用一些空白填充不会被修改的数据的前后

### cpu是如何选择线程的

在linux中 进程和线程都是用 task_struct 结构体表示的 区别在于 线程的结构体内的一些资源是共享进程已经创建的资源 如代码段等 所以线程也被称为轻量级进程
线程进程统称为任务
linux中根据任务优先级及响应要求 主要分为两种 优先级数值越小 优先度越高

1. 实时任务 要尽可能快的执行 优先级0 ~ 99
2. 普通任务 没有很高要求 100 ~ 139

#### 调度类

为了保障高优先级的任务能够尽可能早的执行

#### 完全公平调度

我们遇到的基本都是普通任务 公平性很重要 linux中有一个基于cfs（完全公平调度）的调度算法
它为每一个任务安排一个虚拟运行时间 在运行的程序 运行得越久 虚拟时间就越大 没有运行的 虚拟运行时间不变 调度的时候会优先选择虚拟运行时间小的 考虑到 优先级 还需要加权 让优先级高的虚拟运行时间短

#### cpu运行队列

每个核心都有自己的任务队列
完全公平调度对应的队列是用红黑树实现的 按虚拟运行时间排序

#### 调整优先级

启动任务 默认是普通任务 可以通过调整nice值调整优先级 但是仍然是普通任务 如果要进一步调整 就要改变任务的优先级和调度策略 使其变为实时任务

## 软中断

### 中断是什么

系统响应硬件设备请求的一种机制 操作系统收到请求后 会打断正在执行的程序 调用中断处理程序响应请求
中断是一种异步事件处理机制 可以提高系统的并发能力 中断处理程序要尽可能快的执行完 减少对正常进程运行调度的影响 而且 中断处理程序响应中断时 可能会临时关闭中断 这时系统的其他中断请求都无法被响应 可能会丢失中断

#### linux软中断

linux为了解决中断处理程序执行过长和中断丢失的问题 将中断过程分为了两个阶段

1. 上半部分快速处理中断 一般会暂时关闭中断请求 主要负责处理跟硬件紧密相关或者时间敏感的事情
2. 下半部分延迟处理上半部为完成的工作 以内核线程的方式运行

也可以理解为

1. 上半部直接处理硬件请求 也就是硬中断 主要负责耗时短的 特点是快速执行
2. 由内核触发 软中断 负责上半部未完成的工作 耗时较长 延迟执行
所以硬中断会打断cpu正在执行的任务 然后立即执行 而软中断是以内核线程的方式运行 每一个cpu核心对应一个软中断内核线程 一些内核自定义事件也属于软中断

#### 系统中的软中断

软中断是以内核线程的方式运行的 所以用ps命令（显示当前运行进程的状态 类似windows的任务管理器）可以看到  内核线程的名字外面都有中括号 因为ps无法获取他们的命令行参数 所以一般来说 名字在中括号里面的都可以认为是内核线程

#### 如何定位软中断cpu使用率过高的问题

要想知道当前的系统的软中断情况 我们可以使用top命令查看 si代表软中断 可以得到cpu软中断的使用率 根据不同类型软中断的中断次数变化速率可以确定哪种软中断占比最高 比如web服务器就可以分析哪个网卡对应的中断最多 再抓包分析

## 负数 小数的表示

### 负数用补码表示

int 32位 最高位是符号标志位 0表示正数 1表示负数 剩下31位表示2进制数据
负数是以补码表示的 就是把其对应的正数（绝对值）二进制全部取反再加1
使用补码的方式在进行加减法时 直接用二进制的规则即可 提高了运算的效率 所以补码就相当于用0 减去其绝对值

### 小数用浮点数

一种表示方法是使用定点数 小数点后第一个二进制位表示2的-1次方 但是有很多小数无非被这样表示
计算机采用浮点数的方式（类似科学计数法）比如1000.101（二进制定点数）写为浮点数就是 1.000101 * 2 ^ 3 最关键的是000101和3 000101称为尾数 3称为指数 然后还需要一个符号位
符号位表示正负 0为正 1为负 指数位长度决定了数值的表达范围 尾数位长度决定了数值的精度
32位的浮点数为单精度 float 64位的是双精度 double
指数在存储过程中会加上一个正的偏移量 用无符号整数存储
因为有的十进制小数无法转换为精确的二进制定点数 所以小数在计算机中是近似的

# 操作系统结构

## linux内核和windows内核

### 内核

内核是应用和硬件的中间层 让应用只需要和内核交互 而无需关心硬件 降低了开发难度
现代操作系统 内核一般会提供4大基本能力

1. 进程调度 决定哪个进程使用cpu
2. 内存管理 决定内存的分配与回收
3. 管理硬件 为进程与硬件间提供通讯能力
4. 提供系统调用 用户程序通过这个方式与系统交互

为了安全 内核的权限很高 可以控制硬件 而应用程序权限小 内存被分为两个区域 内核空间（只有内核才有权访问）和用户空间（专门给用户程序使用）
在内核空间称为内核态 在用户空间称为用户态 应用程序如果需要进入内核态 就需要系统调用
过程 应用程序使用系统调用时 产生中断 cpu运行中断处理程序 也就是开始执行内核处理程序 处理完后 主动触发中断 回到用户态

### linux

基于c语言 开源
内核设计理念主要有以下几点

1. multitask 多任务
2. smp 对称多处理
3. elf 可执行文件链接格式
4. monolithic kernel 宏内核

#### 多任务

多任务表示多个任务可以并发或并行执行 每个任务执行一小段时间就切换到另一个任务 宏观来看一段时间执行了多个任务 这叫并发
多个任务被不同cpu同时执行 这叫并行

#### smp 对称多处理

代表每个cpu核心地位相等 每个核心都可以访问完整的硬件资源
每个程序都可以被分配到任意一个cpu核心上执行

#### elf

是linux中可执行文件的存储格式 elf将文件分段
elf的生成
我们编写的代码 首先通过编译器变成汇编代码 然后通过汇编器变成目标代码 最后通过链接器 把多个目标文件及调用的各种函数库链接起来 形成elf文件
elf的执行
通过装载器把elf装载到内存中 然后取指执行

#### 宏内核

linux内核是一个完整的可执行程序 并且拥有最高权限
特征 系统内核所有模块 如进程调度 内存管理等都运行在内核态
但是linux也实现了动态加载内核模块的功能 比如大部分驱动就是动态加载的 与内核其他模块解耦 让驱动开发与加载更为方便灵活
与其相反的是微内核
内核只保留最基本的能力 而其他的被放到了用户空间 比如驱动程序 文件系统 这样服务与服务之间是隔离的 单个服务出现故障不会导致整个操作系统崩溃 提高了操作系统的稳定性和可靠性
微内核功能少 可移植性高 但是不好的地方在于 由于驱动不在内核中 而驱动需要频繁与硬件交互 这就需要频繁切换到内核态 带来了系统损耗 鸿蒙就是微内核
还有一种是混合内核 架构有点像宏内核包裹着一个微内核

### windows

Windows的内核叫Windows nt
windows和linux一样 也支持multitask和smp 但是不同的是 windows的内核设计是混合型的 可执行文件的格式也不同 Windows的可执行文件格式叫pe 扩展名通常是.exe .dll .sys等

# 内存管理
