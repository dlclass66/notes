
# 死锁

两个线程 两个互斥锁就可能触发 比如a线程 先获取了a锁 执行完一部分工作后 需要获得b锁 进行后续工作 但是在a工作的同时b获取了b锁 而b继续工作需要a锁 这样两个线程就死锁了
c++ linux可以用pstack排查死锁
最常见的解决方法 使用资源有序法 ab线程都先访问a资源 再访问b资源

# 锁的类型

## 互斥锁与自旋锁

互斥锁加锁失败就放弃 自旋锁加锁失败就循环尝试

## 读写锁

读锁 可以共享给其它读操作 加了读锁 其他进程可读不可写
写锁 独占 加了写锁 其他进程不可读不可写

## 乐观锁与悲观锁

悲观就是修改共享资源就加锁
乐观就是不加锁 修改完后发现出现不一致就放弃本次操作 全程不加锁 比如在线文档 git

# 线程崩溃进程崩溃

c/cpp 会 java不会

# mysql相关

## 事务隔离级别

1. 读未提交 还没提交 结果就对其他事务可见 最容易出现问题
2. 读提交 提交后才能被其他事务看见
3. 可重复读 一个事务执行过程中 看到的数据一直和启动时看到的数据一致 innodb引擎默认
4. 串行化 对一条数据的读写采用串行

## 脏读 不可重复读 幻读

严重性从大到小
脏读 读到了其他事务未提交的数据
不可重复读 事务进行过程中 读到的数据不一致
幻读 查询语句前后执行的结果行数不一致

## sql优化

1. 避免使用select** 只查询想要的 主要问题 select * 会回表 不走索引覆盖
2. 不需要去重就用union all 代替union
3. 小表驱动大表 子查询先查小表
4. 多用limit
5. 用连接代替子查询
6. 索引优化 用explain查看情况

## b+树

采用b+树的主要原因是b+树 树矮 需要的磁盘io次数少

# 计算机网络

## get与post

按rcf规定 get是请求服务器指定资源 安全 幂等 可缓存 post是根据请求负荷 对指定资源做出处理 不安全 不幂等 一般不可缓存
不过具体应用不一定和rcf规定一样

## tcp和udp

tcp面向连接 一对一 udp不面向连接 tcp保证可靠交付数据 udp不保证 tcp是流式传输 udp是一个包一个包传输 tcp还有拥塞控制 tcp用于http ftp等 udp用于dns 音视频等

## 全双工与半双工

单工 只能单向传输
双工 可发可收
全双工 服务端客户端可以同时收发
tcp握手是半双工 正常连接是全双工 还要考虑应用层

## http各版本

1.1多了管道和长连接 

# 读取文件的操作

## fstream

是一个文件读写流
下面是一个把cpp代码输出成文本格式的例子

```cpp
#include <iostream>
#include <fstream>
#include <string>

int main() {
    //创建一个输入流 参数是文件的位置 注意是 '//'
    std::ifstream in("C:\\Users\\DL\\source\\repos\\project_file_test\\project_file_test\\test.cpp");
    //创建一个输出流 注意等下不是输出到cout了 文件不存在会自动创建
    std::ofstream out("C:\\Users\\DL\\source\\repos\\project_file_test\\project_file_test\\out.txt");
    std::string s;
    //因为<<遇到空格就停 所以用getline
    while (getline(in, s)) {
        out << s << std::endl;
    }
    while (1);
}
```

# 多线程

## 消费者生产者

简单示例

```cpp
#include <mutex>
#include <thread>
#include <condition_variable>
#include <iostream>
#include <queue>

class workqueue {
private:
    std::queue<int> qu;
    std::mutex mtx;
    std::condition_variable cv;
    int maxsize;
public:
    workqueue(int size) :maxsize(size) {}
    bool push(int date) {
        std::unique_lock<std::mutex> lock(mtx);
        if (qu.size() >= maxsize) {
            cv.notify_all();
            lock.unlock();
            return false;
        }
        qu.push(date);
        cv.notify_all();
        std::cout << "product: " << date << std::endl;
        lock.unlock();
        return true;
    }
    int pop() {
        std::unique_lock<std::mutex> lock(mtx);
        while (qu.empty()) {
            cv.wait(lock);
        }
        int tmp = qu.front();
        qu.pop();
        cv.notify_all();
        std::cout << "consume: " << tmp << std::endl;
        lock.unlock();
        return tmp;
    }
};


void produce(workqueue* wq) {
    for (int i = 0; i < 100; i++) {
        if (wq->push(i)) {
        }
        else {
            i--;
        }
    }
}


void consume(workqueue* wq) {
    int count = 0;
    while (count < 100) {
        int temp = wq->pop();
        count++;
    }
}

int main() {
    workqueue wq(1);
    std::mutex mut;
    std::thread t1(produce, &wq);
    std::thread t2(consume, &wq);
    t1.join();
    t2.join();
    while (1);
}
```

## 多线程按顺序执行

简单示例

```cpp
#include <iostream>
#include <fstream>
#include <string>
#include <mutex>
#include <condition_variable>
#include <thread>

//因为每个线程要共享 所以锁 条件变量都使用全局变量
std::mutex mu;
std::condition_variable cv;
//用一个变量确定当前要执行的线程 其余阻塞 这样只需要一个条件变量
int flag = 0;

void myout(std::ifstream& in, int num) {
    std::string s;
    while (getline(in, s)) {
        std::unique_lock<std::mutex> locker(mu);
        if (flag == num) {
            std::cout << s << std::endl;
            if (num == 1) {
                flag = 0;
            } else {
                flag = 1;
            }
            cv.notify_all();
        }
        else {
            cv.wait(locker);
        }
    }
}

int main() {

    std::ifstream in1("C:\\Users\\DL\\source\\repos\\project_file_test\\project_file_test\\in1.txt");
    std::ifstream in2("C:\\Users\\DL\\source\\repos\\project_file_test\\project_file_test\\in2.txt");

    //传引用 使用std::ref 用一个标志位区分 而不是写两个线程函数
    std::thread t1(myout, std::ref(in1), 1);
    std::thread t2(myout, std::ref(in2), 0);
    t1.join();
    t2.join();
    while (1);
}
```

# redis

## lru lfu

lru 淘汰上次使用距今最远的 通常底层是链表加哈希表
redis 使用随机抽样的方法 但是解决不了缓存污染问题

lfu 淘汰最近使用次数最少的 可以用链表加哈希表实现
